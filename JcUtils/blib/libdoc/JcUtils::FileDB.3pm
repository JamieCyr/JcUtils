.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "JcUtils::FileDB 3pm"
.TH JcUtils::FileDB 3pm "2012-11-28" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
JcUtils::FileDB \- The great new JcUtils::FileDB!
.SH "VERSION"
.IX Header "VERSION"
Version 0.01
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Flat file data base for hashes.
Stores data in a flat file using \s-1JSON\s0 format.
Smartly opens and closes the flat file db; creating 10 entries in a row opens the file once and closes
it when necessary for a reading operation such at \fIfetch()\fR;
.PP
Perhaps a little code snippet.
.PP
.Vb 1
\&    my $defaultdb = JcUtils::FileDB::new();
\&    
\&    my $logger = JcUtils::Logger::new("/tmp/myLogfile");
\&    my $mydb = JcUtils::FileDB::new($logger, "/tmp/myDbFile");
\&    
\&    my $hashDb = JcUtils::FileDB::new({
\&         \*(AqdbFile\*(Aq       =>      \*(Aq/tmp/hashDbFile\*(Aq,
\&         \*(Aqlogger\*(Aq       =>      $logger,
\&         \*(AqmaxRecords\*(Aq   => 10000
\&    });
.Ve
.SH "EXPORT"
.IX Header "EXPORT"
None.
.SH "SUBROUTINES/METHODS"
.IX Header "SUBROUTINES/METHODS"
.SS "\fInew()\fP"
.IX Subsection "new()"
Cretes the new FileDb object.  You can use a hasref or individule arguments in the correct order.
.PP
\fIArguments\fR
.IX Subsection "Arguments"
.IP "1. Object, JcUtils::Logger, user provided logger" 4
.IX Item "1. Object, JcUtils::Logger, user provided logger"
.PD 0
.IP "2. String, dbFile file name" 4
.IX Item "2. String, dbFile file name"
.IP "3. Number, maxRecords size, the max amount of records in the \s-1DB\s0" 4
.IX Item "3. Number, maxRecords size, the max amount of records in the DB"
.PD
.PP
\fIReturn\fR
.IX Subsection "Return"
.IP "1. Object, new FileDb object" 2
.IX Item "1. Object, new FileDb object"
.SS "\fIcreate()\fP"
.IX Subsection "create()"
Create a database record. Returns the \s-1UUID\s0 of the recored created.
.PP
\fIArguments\fR
.IX Subsection "Arguments"
.IP "1. Hashref, hashref of the data structure to store" 2
.IX Item "1. Hashref, hashref of the data structure to store"
.PP
\fIReturn\fR
.IX Subsection "Return"
.IP "1. Number, \s-1UUID\s0 of the entry." 3
.IX Item "1. Number, UUID of the entry."
.PD 0
.IP "2. Number, 0 on failure." 3
.IX Item "2. Number, 0 on failure."
.PD
.SS "\fIupdate()\fP"
.IX Subsection "update()"
Udate a record in the \s-1DB\s0
.PP
\fIArguments\fR
.IX Subsection "Arguments"
.IP "1. Hashref, Hash reference with \s-1UUID\s0 field." 2
.IX Item "1. Hashref, Hash reference with UUID field."
.PP
\fIReturn\fR
.IX Subsection "Return"
.IP "1. Number, 1 for Success." 3
.IX Item "1. Number, 1 for Success."
.PD 0
.IP "2. Number, 0 for failure." 3
.IX Item "2. Number, 0 for failure."
.PD
.SS "\fIdelete()\fP"
.IX Subsection "delete()"
Delete entry in the database.
.PP
\fIArguments\fR
.IX Subsection "Arguments"
.IP "1. Number, \s-1UUID\s0 of the record to delete" 2
.IX Item "1. Number, UUID of the record to delete"
.PP
\fIReturn\fR
.IX Subsection "Return"
.IP "1. Number, 1 success, 0 failure" 2
.IX Item "1. Number, 1 success, 0 failure"
.SS "\fIgetNext()\fP"
.IX Subsection "getNext()"
Return next record in the database.  Used in conjuction with the \fImoreEntries()\fR method.
.PP
.Vb 4
\&        my $entry = {};
\&        while ($mydb\->moreEntries()) {
\&                $entry = $mydb\->getNext();
\&        }
.Ve
.PP
\fIArguments\fR
.IX Subsection "Arguments"
.PP
\fIReturn\fR
.IX Subsection "Return"
.IP "1. Hashref, hash reference of the object." 2
.IX Item "1. Hashref, hash reference of the object."
.SS "\fImoreEntries()\fP"
.IX Subsection "moreEntries()"
Starts at an index and returns true until there are no other records.
.PP
\fIArgument\fR
.IX Subsection "Argument"
.PP
\fIReturn\fR
.IX Subsection "Return"
.IP "1. Number, 1 true 0, false" 2
.IX Item "1. Number, 1 true 0, false"
.SS "\fIsetIndex()\fP"
.IX Subsection "setIndex()"
Set the database index number.
.PP
\fIArguments\fR
.IX Subsection "Arguments"
.IP "1. Number, Index value" 2
.IX Item "1. Number, Index value"
.PP
\fIReturn\fR
.IX Subsection "Return"
.IP "1. Number, 1 success, 0 failure" 2
.IX Item "1. Number, 1 success, 0 failure"
.SS "\fIfind()\fP"
.IX Subsection "find()"
Find a record in the db, return an array of UUIDs, empty array if nothing was found.  Use \fIfetch()\fR method to
acutally obtain the record. The \fIfind()\fR method will return any entry that contains the search string.
.PP
\fIArguments\fR
.IX Subsection "Arguments"
.IP "1. String, key to find" 4
.IX Item "1. String, key to find"
.PD 0
.IP "2. String, the string to search for" 4
.IX Item "2. String, the string to search for"
.IP "3. Number, 1=ignore case" 4
.IX Item "3. Number, 1=ignore case"
.PD
.PP
\fIReturn\fR
.IX Subsection "Return"
.IP "1. Array, array of restuls, empty array if no results found or failure." 2
.IX Item "1. Array, array of restuls, empty array if no results found or failure."
.SS "\fIfetch()\fP"
.IX Subsection "fetch()"
Fetch a record from the db.  If it doesn't exist return empty hashref
.PP
\fIArguments\fR
.IX Subsection "Arguments"
.IP "1. Number, the \s-1UUID\s0 of the record" 2
.IX Item "1. Number, the UUID of the record"
.PP
\fIReturn\fR
.IX Subsection "Return"
.IP "1. Hashref, hash reference of the object." 2
.IX Item "1. Hashref, hash reference of the object."
.PD 0
.IP "2. Number, 0 on failure." 2
.IX Item "2. Number, 0 on failure."
.PD
.SS "\fIgetRecordCount()\fP"
.IX Subsection "getRecordCount()"
Get the number of records in the \s-1DB\s0.
.PP
\fIReturns\fR
.IX Subsection "Returns"
.IP "1. Number, number of records in the data base" 2
.IX Item "1. Number, number of records in the data base"
.SS "\fIcloseDb()\fP"
.IX Subsection "closeDb()"
Convenience function that opens the flat file data base.
.PP
\fIReturn\fR
.IX Subsection "Return"
.IP "1. Number, 1 success." 3
.IX Item "1. Number, 1 success."
.PD 0
.IP "2. Number, 0 failure." 3
.IX Item "2. Number, 0 failure."
.PD
.SS "\fIopenDb()\fP"
.IX Subsection "openDb()"
Convenience function that closes the flat file data base.
.PP
\fIReturn\fR
.IX Subsection "Return"
.IP "1. Number, 1 success." 3
.IX Item "1. Number, 1 success."
.PD 0
.IP "2. Number, 0 failure." 3
.IX Item "2. Number, 0 failure."
.PD
.SH "AUTHOR"
.IX Header "AUTHOR"
Jamie Cyr, \f(CW\*(C`<jjcyr at yahoo.com>\*(C'\fR
.SH "BUGS"
.IX Header "BUGS"
.SS "\fIdelete()\fP"
.IX Subsection "delete()"
The \fIdelete()\fR function is not yet implemented.
.PP
Please report any bugs or feature requests to \s-1TBD\s0.
.SH "SUPPORT"
.IX Header "SUPPORT"
You can find documentation for this module with the perldoc command.
.PP
.Vb 1
\&    perldoc JcUtils::FileDB
.Ve
.PP
You can also look for information at: \s-1TBD\s0
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
None.
.SH "LICENSE AND COPYRIGHT"
.IX Header "LICENSE AND COPYRIGHT"
Copyright 2012 Jamie Cyr.
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of either: the \s-1GNU\s0 General Public License as published
by the Free Software Foundation; or the Artistic License.
.PP
See http://dev.perl.org/licenses/ for more information.
